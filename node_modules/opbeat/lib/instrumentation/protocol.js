'use stirct'

var afterAll = require('after-all-results')
var knownGroupingKeys = require('hashlru')(5000)
var objectAssign = require('object-assign')
var debug = require('debug')('opbeat')
var stackman = require('../stackman')
var parsers = require('../parsers')

exports.encode = encode
exports.transactionGroupingKey = transactionGroupingKey

/**
 * Encodes recorded transactions into a format expected by the Opbeat intake
 * API.
 *
 * samples:
 *   An array containing objects of type Transaction. It's expected that each
 *   Transaction have a unique name within a 15ms window based on its duration.
 *
 * durations:
 *   An object whos keys are generated by `transactionGroupingKey`. Each value
 *   is an array of floats representing the duration in milliseconds of each
 *   recorded Transaction that belongs to that key.
 *
 * cb:
 *   A callback which will be called with the encoded data.
 */
function encode (samples, durations, cb) {
  var agent = samples.length > 0 ? samples[0]._agent : null
  var transactions = groupTransactions(samples, durations)
  var traces = [].concat.apply([], samples.map(function (trans) {
    return trans.traces
  }))
  var groups = groupTraces(traces)
  var raw = rawTransactions(samples)

  if (agent && agent.captureTraceStackTraces) {
    addStackTracesToTraceGroups(groups, traces, done)
  } else {
    process.nextTick(done)
  }

  function done () {
    cb({ // eslint-disable-line standard/no-callback-literal
      transactions: transactions,
      traces: {
        groups: groups,
        raw: raw
      }
    })
  }
}

function groupTransactions (samples, durations) {
  var groups = groupByKey(samples, transactionGroupingKey)

  return Object.keys(groups).map(function (key) {
    var trans = groups[key][0] // a transaction to represent this group
    return {
      transaction: trans.name,
      result: trans.result,
      kind: trans.type,
      timestamp: new Date(groupingTs(trans._start)).toISOString(),
      durations: durations[key]
    }
  })
}

function groupTraces (traces) {
  var groups = groupByKey(traces, traceGroupingKey)

  return Object.keys(groups).map(function (key, index) {
    var trace = groups[key][0] // a trace to represent this group
    groups[key].forEach(function (trace) {
      trace._groupIndex = index
    })
    return {
      transaction: trace.transaction.name,
      signature: trace.name,
      kind: trace.truncated ? trace.type + '.truncated' : trace.type,
      transaction_kind: trace.transaction.type,
      timestamp: new Date(groupingTs(trace._start)).toISOString(),
      parents: trace.ancestors(),
      extra: trace.extra
    }
  })
}

function rawTransactions (transactions) {
  var raw = []

  transactions.forEach(function (trans) {
    if (trans.traces.length === 0) return

    var context = {
      extra: objectAssign({
        node: process.version,
        id: trans.id
      }, trans._context && trans._context.extra)
    }

    if (trans.req) {
      context.http = parsers.getHTTPContextFromRequest(trans.req, {body: trans._agent._logBody})
    }

    context.user = objectAssign(
      {},
      trans.req && parsers.getUserContextFromRequest(trans.req),
      trans._context && trans._context.user
    )

    var arr = rawTraces(trans.traces)
    arr.unshift(trans.duration())
    arr.push(context)
    raw.push(arr)
  })

  return raw
}

function rawTraces (traces) {
  return traces.map(function (trace) {
    return [trace._groupIndex, trace.startTime(), trace.duration()]
  })
}

function addStackTracesToTraceGroups (groups, traces, cb) {
  var processed = []
  var next = afterAll(cb)
  traces.forEach(function (trace) {
    var index = trace._groupIndex
    if (~processed.indexOf(index)) return
    processed.push(index)

    var key = stackTraceGroupingKey(trace)
    if (knownGroupingKeys.get(key)) return
    knownGroupingKeys.set(key, true)

    var done = next()
    traceFrames(trace, function (frames) {
      if (frames) groups[index].extra._frames = frames.reverse()
      done()
    })
  })
}

function traceFrames (trace, cb) {
  if (trace._stackObj.frames) {
    process.nextTick(function () {
      cb(trace._stackObj.frames)
    })
    return
  }

  stackman.callsites(trace._stackObj.err, function (err, callsites) {
    if (!callsites) {
      debug('could not capture stack trace for trace %o', {id: trace.transaction.id, name: trace.name, type: trace.type, err: err && err.message})
      cb()
      return
    }

    if (!process.env.OPBEAT_TEST) callsites = callsites.filter(filterCallsite)

    var next = afterAll(function (_, frames) {
      // As of now, parseCallsite suppresses errors internally, but even if
      // they were passed on, we would want to suppress them here anyway
      trace._stackObj.frames = frames
      cb(frames)
    })

    callsites.forEach(function (callsite) {
      parsers.parseCallsite(callsite, next())
    })
  })
}

function filterCallsite (callsite) {
  var filename = callsite.getFileName()
  return filename ? filename.indexOf('/node_modules/opbeat/') === -1 : true
}

/**
 * Group an array (arr) of objects using the given grouping function (grouper).
 *
 * Only requirement is that the grouping function - given an object - returns a
 * key that should be used to group that object.
 *
 * Returns an object where each key represents a group. Each value in the
 * object is an array containing the objects that fall into that group.
 */
function groupByKey (arr, grouper) {
  var groups = {}

  arr.forEach(function (obj) {
    var key = grouper(obj)
    if (key in groups) groups[key].push(obj)
    else groups[key] = [obj]
  })

  return groups
}

function transactionGroupingKey (trans) {
  return groupingTs(trans._start) +
    '|' + trans.name +
    '|' + trans.result +
    '|' + trans.type
}

function traceGroupingKey (trace) {
  return groupingTs(trace.transaction._start) +
    '|' + trace.transaction.name +
    '|' + trace.ancestors().join('|') +
    '|' + trace.name
}

function stackTraceGroupingKey (trace) {
  return trace.type +
    '|' + trace.name +
    '|' + trace.transaction.name +
    '|' + trace.ancestors().join('|')
}

/**
 * Convert a number representing the milliseconds elapsed since the UNIX epoch
 * to whole minutes.
 *
 * Or in other words it converts:
 *   2016-10-23T15:23:53.345Z
 * To:
 *   2016-10-23T15:23:00.000Z
 */
function groupingTs (ms) {
  return Math.floor(ms / 1000 / 60) * 1000 * 60
}
